
# 2차원 리스트의 회전

- 90도 (규칙성만 기억하면 180, 270도 해결 가능)
def rotate_90(m):
    N = len(m)
    ret = [[0] * N for _ in range(N)]
    

    for r in range(N):
        for c in range(N):
            ret[c][N-1-r] = m[r][c]
    return ret
    ---- 설명 : https://shoark7.github.io/programming/algorithm/rotate-2d-array -----




# for loop

- basic
for i in range(n) : <------------ 0 부터 n-1 까지

- with list
data = [1, 2, 3]
for item in data : <----------item에 data[0], data[1] ... 이 대입




# list

- pop & remove
list.pop(by idx)
list.pop(-1) <--------제일 마지막 idx
list.remove(by value)

- 복사 (얕은 / 깊은 복사)
> 얕은 복사(를 하게되면 b의 vaule를 바꿀 때 a의 value도 바뀐다)
  b = copy.copy(a)
  또는
  b = a[:]

> 깊은 복사(를 하게되면 a와 b의 value가 독립적으로 작용)
  b = copy.deepcopy(a)




# dictionary

- 선언
dic = {}

- 접근
value = dic["noa"]   <----- 'noa'의 쌍을 반환 e.g) {'noa':1, 'kafka':2} 이면 1을 반환

- 데이터 변경
dic['noa'] = 3

- 데이터 삭제
del dic['noa']

- 존재여부 확인
if 'noa' in dic : <-------true or false




# 순열과 조합

- import
from itertools import permutation

- 순열 Usage
data = [1, 2, 3]
list(map(''.join, permutations(data)))    <----- 1,2,3 / 1,3,2 / 2,1,3 / 2,3,1 / 3,1,2 / 3,2,1
list(map(''.join, permutations(data), 2)) <----- 1,2 / 1,3 / 2,1 / 2,3 / 3,1 / 3,2

- 조합 Usage
data = [1, 2, 3]
num = 3 (or 2...)
list(itertools.combinations(data, num))

